// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: albums.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAlbums = `-- name: CountAlbums :one
SELECT COUNT(*) FROM albums
`

func (q *Queries) CountAlbums(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAlbums)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAlbumsByEvent = `-- name: CountAlbumsByEvent :one
SELECT COUNT(*) FROM albums
WHERE event_id = $1
`

func (q *Queries) CountAlbumsByEvent(ctx context.Context, eventID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countAlbumsByEvent, eventID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAlbumsByUser = `-- name: CountAlbumsByUser :one
SELECT COUNT(*) FROM albums
WHERE created_by_user_id = $1
`

func (q *Queries) CountAlbumsByUser(ctx context.Context, createdByUserID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countAlbumsByUser, createdByUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAlbum = `-- name: CreateAlbum :one
INSERT INTO albums (event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated
`

type CreateAlbumParams struct {
	EventID         int64
	CreatedByUserID pgtype.Int8
	UpdatedByUserID pgtype.Int8
	Name            string
	Description     pgtype.Text
	CoverImageUrl   pgtype.Text
	IsPublic        pgtype.Bool
	ShareUUID       pgtype.Text
	Passcode        pgtype.Text
	Created         int64
	Updated         int64
}

func (q *Queries) CreateAlbum(ctx context.Context, arg CreateAlbumParams) (Album, error) {
	row := q.db.QueryRow(ctx, createAlbum,
		arg.EventID,
		arg.CreatedByUserID,
		arg.UpdatedByUserID,
		arg.Name,
		arg.Description,
		arg.CoverImageUrl,
		arg.IsPublic,
		arg.ShareUUID,
		arg.Passcode,
		arg.Created,
		arg.Updated,
	)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CreatedByUserID,
		&i.UpdatedByUserID,
		&i.Name,
		&i.Description,
		&i.CoverImageUrl,
		&i.IsPublic,
		&i.ShareUUID,
		&i.Passcode,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteAlbum = `-- name: DeleteAlbum :exec
DELETE FROM albums
WHERE id = $1
`

func (q *Queries) DeleteAlbum(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAlbum, id)
	return err
}

const getAlbumByID = `-- name: GetAlbumByID :one
SELECT id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated FROM albums
WHERE id = $1
`

func (q *Queries) GetAlbumByID(ctx context.Context, id int64) (Album, error) {
	row := q.db.QueryRow(ctx, getAlbumByID, id)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CreatedByUserID,
		&i.UpdatedByUserID,
		&i.Name,
		&i.Description,
		&i.CoverImageUrl,
		&i.IsPublic,
		&i.ShareUUID,
		&i.Passcode,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getAlbumByShareUUID = `-- name: GetAlbumByShareUUID :one
SELECT id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated FROM albums
WHERE share_uuid = $1
`

func (q *Queries) GetAlbumByShareUUID(ctx context.Context, shareUuid pgtype.Text) (Album, error) {
	row := q.db.QueryRow(ctx, getAlbumByShareUUID, shareUuid)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CreatedByUserID,
		&i.UpdatedByUserID,
		&i.Name,
		&i.Description,
		&i.CoverImageUrl,
		&i.IsPublic,
		&i.ShareUUID,
		&i.Passcode,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const listAlbums = `-- name: ListAlbums :many
SELECT id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated FROM albums
ORDER BY created DESC
LIMIT $1 OFFSET $2
`

type ListAlbumsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAlbums(ctx context.Context, arg ListAlbumsParams) ([]Album, error) {
	rows, err := q.db.Query(ctx, listAlbums, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CreatedByUserID,
			&i.UpdatedByUserID,
			&i.Name,
			&i.Description,
			&i.CoverImageUrl,
			&i.IsPublic,
			&i.ShareUUID,
			&i.Passcode,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlbumsByEvent = `-- name: ListAlbumsByEvent :many
SELECT id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated FROM albums
WHERE event_id = $1
ORDER BY created DESC
LIMIT $2 OFFSET $3
`

type ListAlbumsByEventParams struct {
	EventID int64
	Limit   int32
	Offset  int32
}

func (q *Queries) ListAlbumsByEvent(ctx context.Context, arg ListAlbumsByEventParams) ([]Album, error) {
	rows, err := q.db.Query(ctx, listAlbumsByEvent, arg.EventID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CreatedByUserID,
			&i.UpdatedByUserID,
			&i.Name,
			&i.Description,
			&i.CoverImageUrl,
			&i.IsPublic,
			&i.ShareUUID,
			&i.Passcode,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlbumsByUser = `-- name: ListAlbumsByUser :many
SELECT id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated FROM albums
WHERE created_by_user_id = $1
ORDER BY created DESC
LIMIT $2 OFFSET $3
`

type ListAlbumsByUserParams struct {
	CreatedByUserID pgtype.Int8
	Limit           int32
	Offset          int32
}

func (q *Queries) ListAlbumsByUser(ctx context.Context, arg ListAlbumsByUserParams) ([]Album, error) {
	rows, err := q.db.Query(ctx, listAlbumsByUser, arg.CreatedByUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CreatedByUserID,
			&i.UpdatedByUserID,
			&i.Name,
			&i.Description,
			&i.CoverImageUrl,
			&i.IsPublic,
			&i.ShareUUID,
			&i.Passcode,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicAlbumsByEvent = `-- name: ListPublicAlbumsByEvent :many
SELECT id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated FROM albums
WHERE event_id = $1 AND is_public = true
ORDER BY created DESC
LIMIT $2 OFFSET $3
`

type ListPublicAlbumsByEventParams struct {
	EventID int64
	Limit   int32
	Offset  int32
}

func (q *Queries) ListPublicAlbumsByEvent(ctx context.Context, arg ListPublicAlbumsByEventParams) ([]Album, error) {
	rows, err := q.db.Query(ctx, listPublicAlbumsByEvent, arg.EventID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CreatedByUserID,
			&i.UpdatedByUserID,
			&i.Name,
			&i.Description,
			&i.CoverImageUrl,
			&i.IsPublic,
			&i.ShareUUID,
			&i.Passcode,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAlbumsByEvent = `-- name: SearchAlbumsByEvent :many
SELECT id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated FROM albums
WHERE event_id = $1
  AND (name ILIKE '%' || $2 || '%' OR description ILIKE '%' || $2 || '%')
ORDER BY created DESC
LIMIT $3 OFFSET $4
`

type SearchAlbumsByEventParams struct {
	EventID int64
	Column2 pgtype.Text
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchAlbumsByEvent(ctx context.Context, arg SearchAlbumsByEventParams) ([]Album, error) {
	rows, err := q.db.Query(ctx, searchAlbumsByEvent,
		arg.EventID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CreatedByUserID,
			&i.UpdatedByUserID,
			&i.Name,
			&i.Description,
			&i.CoverImageUrl,
			&i.IsPublic,
			&i.ShareUUID,
			&i.Passcode,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlbum = `-- name: UpdateAlbum :one
UPDATE albums
SET name = COALESCE($3, name),
    description = COALESCE($4, description),
    cover_image_url = COALESCE($5, cover_image_url),
    is_public = COALESCE($6, is_public),
    share_uuid = COALESCE($7, share_uuid),
    passcode = COALESCE($8, passcode),
    updated_by_user_id = COALESCE($9, updated_by_user_id),
    updated = $1
WHERE id = $2
RETURNING id, event_id, created_by_user_id, updated_by_user_id, name, description, cover_image_url, is_public, share_uuid, passcode, created, updated
`

type UpdateAlbumParams struct {
	Updated         int64
	ID              int64
	Name            pgtype.Text
	Description     pgtype.Text
	CoverImageUrl   pgtype.Text
	IsPublic        pgtype.Bool
	ShareUUID       pgtype.Text
	Passcode        pgtype.Text
	UpdatedByUserID pgtype.Int8
}

func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) (Album, error) {
	row := q.db.QueryRow(ctx, updateAlbum,
		arg.Updated,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CoverImageUrl,
		arg.IsPublic,
		arg.ShareUUID,
		arg.Passcode,
		arg.UpdatedByUserID,
	)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CreatedByUserID,
		&i.UpdatedByUserID,
		&i.Name,
		&i.Description,
		&i.CoverImageUrl,
		&i.IsPublic,
		&i.ShareUUID,
		&i.Passcode,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
